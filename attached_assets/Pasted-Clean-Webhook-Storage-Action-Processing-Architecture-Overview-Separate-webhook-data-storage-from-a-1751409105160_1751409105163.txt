Clean Webhook Storage â†’ Action Processing Architecture
Overview
Separate webhook data storage from action processing while maintaining simplicity. This ensures data integrity and enables reliable action processing with NLP capabilities.
Architecture Flow
Evolution API â†’ Webhook Handler â†’ Store Data â†’ Trigger Actions
                    (fast)         (fast)      (can be slower)
Implementation Plan
Phase 1: Update Webhook Handler (Minimal Changes)
typescript// controllers/WebhookController.ts
export class WebhookController {
  async handleWebhook(req: Request, res: Response) {
    const { instanceName } = req.params;
    const webhookData = req.body;
    
    try {
      // 1. Quick validation
      if (!this.validateWebhook(webhookData)) {
        return res.status(400).json({ error: 'Invalid webhook data' });
      }
      
      // 2. Store data (existing logic)
      await this.processWebhookData(webhookData, instanceName);
      
      // 3. Queue action processing (new)
      await this.queueActionProcessing(webhookData);
      
      // 4. Return immediately
      res.status(200).json({ status: 'received' });
      
    } catch (error) {
      console.error('Webhook processing error:', error);
      // Still return 200 to Evolution API to prevent retries
      res.status(200).json({ status: 'received with errors' });
    }
  }
  
  private async processWebhookData(data: any, instanceName: string) {
    // Your existing WhatsApp API Adapter logic
    switch (data.event) {
      case 'messages.upsert':
        await this.whatsappAdapter.storeMessage(data);
        break;
        
      case 'messages.reaction':
        await this.whatsappAdapter.storeReaction(data);
        break;
        
      // Other events...
    }
  }
  
  private async queueActionProcessing(data: any) {
    // Simple database queue - no Redis needed
    if (data.event === 'messages.reaction') {
      await db.query(`
        INSERT INTO action_queue (
          event_type,
          event_data,
          status,
          created_at
        ) VALUES ($1, $2, 'pending', NOW())
      `, ['reaction', data]);
    }
  }
}
Phase 2: Database Queue for Actions
sql-- Simple action queue table
CREATE TABLE action_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT NOT NULL,
  event_data JSONB NOT NULL,
  status TEXT DEFAULT 'pending',
  attempts INTEGER DEFAULT 0,
  max_attempts INTEGER DEFAULT 3,
  last_error TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  processed_at TIMESTAMP,
  completed_at TIMESTAMP
);

-- Indexes for efficient processing
CREATE INDEX idx_action_queue_pending ON action_queue(status, created_at) 
WHERE status = 'pending';

CREATE INDEX idx_action_queue_processing ON action_queue(status, created_at) 
WHERE status = 'processing';
Phase 3: Action Processor Service
typescript// services/ActionProcessorService.ts
export class ActionProcessorService {
  private nlpService: NLPService;
  private isProcessing = false;
  private processInterval: NodeJS.Timer;
  
  constructor() {
    this.nlpService = new NLPService();
  }
  
  start() {
    // Process every 2 seconds
    this.processInterval = setInterval(() => {
      if (!this.isProcessing) {
        this.processNextBatch();
      }
    }, 2000);
    
    console.log('Action Processor started');
  }
  
  stop() {
    if (this.processInterval) {
      clearInterval(this.processInterval);
    }
  }
  
  private async processNextBatch() {
    this.isProcessing = true;
    
    try {
      // Get pending actions
      const batch = await db.query(`
        UPDATE action_queue
        SET status = 'processing'
        WHERE id IN (
          SELECT id FROM action_queue
          WHERE status = 'pending'
          AND attempts < max_attempts
          ORDER BY created_at
          LIMIT 5
          FOR UPDATE SKIP LOCKED
        )
        RETURNING *
      `);
      
      // Process each action
      for (const action of batch.rows) {
        await this.processAction(action);
      }
      
    } catch (error) {
      console.error('Batch processing error:', error);
    } finally {
      this.isProcessing = false;
    }
  }
  
  private async processAction(queueItem: any) {
    try {
      const startTime = Date.now();
      
      switch (queueItem.event_type) {
        case 'reaction':
          await this.processReactionAction(queueItem.event_data);
          break;
          
        case 'message':
          await this.processMessageAction(queueItem.event_data);
          break;
      }
      
      // Mark as completed
      await db.query(`
        UPDATE action_queue 
        SET status = 'completed', 
            completed_at = NOW(),
            processed_at = NOW()
        WHERE id = $1
      `, [queueItem.id]);
      
      console.log(`Action ${queueItem.id} processed in ${Date.now() - startTime}ms`);
      
    } catch (error) {
      // Update error info
      await db.query(`
        UPDATE action_queue 
        SET status = 'pending',
            attempts = attempts + 1,
            last_error = $2
        WHERE id = $1
      `, [queueItem.id, error.message]);
      
      console.error(`Action ${queueItem.id} failed:`, error);
    }
  }
  
  private async processReactionAction(eventData: any) {
    // Get the reaction from database (already stored by webhook handler)
    const reaction = await db.query(`
      SELECT r.*, m.content as message_content, m.user_id as message_user_id
      FROM whatsapp_message_reactions r
      JOIN whatsapp_messages m ON r.message_id = m.id
      WHERE r.id = $1
    `, [eventData.key.id]);
    
    if (!reaction.rows[0]) {
      throw new Error('Reaction not found');
    }
    
    const reactionData = reaction.rows[0];
    
    // Check for NLP-enabled emojis
    if (['ðŸ“…', 'âœ…', 'ðŸ“'].includes(reactionData.reaction)) {
      await this.processNLPAction(reactionData);
    } else {
      // Regular action processing
      await this.actionService.triggerSimpleAction(reactionData);
    }
  }
  
  private async processNLPAction(reactionData: any) {
    // Parse message with NLP
    const parsed = await this.nlpService.parseMessage(
      reactionData.message_content,
      reactionData.reaction
    );
    
    // Store NLP result for analytics
    await db.query(`
      INSERT INTO nlp_processing_log 
      (message_id, reaction_emoji, parsed_type, confidence, success)
      VALUES ($1, $2, $3, $4, $5)
    `, [
      reactionData.message_id,
      reactionData.reaction,
      parsed.type,
      parsed.confidence,
      parsed.confidence > 0.5
    ]);
    
    if (parsed.confidence < 0.5) {
      // Send error message
      await this.whatsappService.sendMessage({
        to: reactionData.user_id,
        message: this.getParsingErrorMessage(reactionData.reaction, parsed.language)
      });
      return;
    }
    
    // Process based on parsed type
    switch (parsed.type) {
      case 'calendar':
        await this.createCalendarEvent(parsed.data, reactionData);
        break;
        
      case 'task':
        await this.createTask(parsed.data, reactionData);
        break;
    }
  }
}
Phase 4: Enhanced WhatsApp API Adapter
typescript// adapters/WhatsAppAPIAdapter.ts
export class WhatsAppAPIAdapter {
  // Remove all action triggering - just store data
  
  async storeMessage(webhookData: any) {
    const message = {
      id: webhookData.key.id,
      user_id: webhookData.key.fromMe ? 'me' : webhookData.key.remoteJid,
      content: webhookData.message.conversation || webhookData.message.extendedTextMessage?.text,
      timestamp: new Date(webhookData.messageTimestamp * 1000),
      // ... other fields
    };
    
    await db.query(`
      INSERT INTO whatsapp_messages (id, user_id, content, timestamp, raw_data)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (id) DO NOTHING
    `, [message.id, message.user_id, message.content, message.timestamp, webhookData]);
    
    // NO ACTION TRIGGERING HERE
  }
  
  async storeReaction(webhookData: any) {
    const reaction = {
      id: webhookData.key.id,
      message_id: webhookData.message.reactionMessage.key.id,
      user_id: webhookData.key.fromMe ? 'me' : webhookData.key.remoteJid,
      reaction: webhookData.message.reactionMessage.text,
      timestamp: new Date(webhookData.messageTimestamp * 1000)
    };
    
    await db.query(`
      INSERT INTO whatsapp_message_reactions (id, message_id, user_id, reaction, timestamp)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (id) DO UPDATE SET reaction = $4
    `, [reaction.id, reaction.message_id, reaction.user_id, reaction.reaction, reaction.timestamp]);
    
    // NO ACTION TRIGGERING HERE
  }
}
Phase 5: Simple Monitoring Dashboard
typescript// api/monitoring.ts
app.get('/api/actions/status', async (req, res) => {
  const stats = await db.query(`
    SELECT 
      status,
      COUNT(*) as count,
      MIN(created_at) as oldest,
      MAX(created_at) as newest,
      AVG(EXTRACT(EPOCH FROM (completed_at - created_at))) as avg_processing_seconds
    FROM action_queue
    WHERE created_at > NOW() - INTERVAL '24 hours'
    GROUP BY status
  `);
  
  const backlog = await db.query(`
    SELECT COUNT(*) as pending_count
    FROM action_queue
    WHERE status = 'pending'
  `);
  
  res.json({
    stats: stats.rows,
    backlog: backlog.rows[0].pending_count,
    health: backlog.rows[0].pending_count < 100 ? 'healthy' : 'warning'
  });
});

// Retry failed actions
app.post('/api/actions/retry/:id', async (req, res) => {
  await db.query(`
    UPDATE action_queue
    SET status = 'pending', attempts = 0
    WHERE id = $1
  `, [req.params.id]);
  
  res.json({ status: 'queued for retry' });
});
Phase 6: Application Startup
typescript// app.ts or index.ts
import { ActionProcessorService } from './services/ActionProcessorService';

async function startApplication() {
  // Your existing app setup...
  
  // Start action processor
  const actionProcessor = new ActionProcessorService();
  actionProcessor.start();
  
  // Graceful shutdown
  process.on('SIGTERM', async () => {
    console.log('Shutting down...');
    actionProcessor.stop();
    await app.close();
    process.exit(0);
  });
}
Benefits of This Approach
âœ… Clean Separation

Webhook handler only stores data
Actions processed separately
Easy to debug each stage

âœ… Reliability

Webhooks never timeout
Failed actions can retry
No data loss

âœ… Flexibility

Easy to add new action types
Can process actions in batches
Rate limiting built-in

âœ… Simplicity

No Redis/Bull complexity
Uses your existing database
Single process (no microservices)

âœ… Observability

Clear queue status
Processing metrics
Error tracking

Migration Steps

Day 1: Deploy database changes (action_queue table)
Day 2: Update webhook handler to queue actions
Day 3: Deploy ActionProcessorService
Day 4: Remove action triggering from webhook handler
Day 5: Monitor and optimize