Of course. Here is the complete application structure translated into the corresponding TypeScript files, as depicted in the architecture diagram in the Canvas.

This new structure is professionally organized into distinct layers, each with a specific responsibility. This makes the application more secure, maintainable, and easier to test.

I have created a separate document for each of the core backend services.

This is the "Front Door" of your application. Its only job is to receive incoming webhooks, validate them, and immediately pass the raw data to the WhatsAppApiAdapter for processing.
1. Webhook Controller (webhook-controller.ts)
Jun 21, 12:37 PM

Open

This is the "Translator" layer. Its job is to take the raw, sometimes inconsistent, JSON from the API and map it into the clean, predictable data structures defined by your database schema.
2. WhatsApp API Adapter (whatsapp-api-adapter.ts)
Jun 21, 12:37 PM

Open

This is the "Brain" of your application. It contains all the complex business logic, including the NLP parsing and the decision-making process for triggering actions.
3. Action Service (action-service.ts)
Jun 21, 12:37 PM

Open

This is the "Warehouse Clerk." Its only job is to execute SQL queries. It doesn't know why it's saving data; it just follows the commands given to it by the Action Service. This file would contain your actual database client and query logic.
4. Storage Layer (storage.ts)
Jun 21, 12:37 PM

Open





i have this webhook structure implemented: its wrong right?



import { Request, Response } from 'express';

import { storage } from './storage';

import * as chrono from 'chrono-node'; // NLP date parsing library

// Import the final table types for clarity and type safety

import {

Â  Â  type WhatsappMessages,

Â  Â  type WhatsappContacts,

Â  Â  type WhatsappChats

} from '@shared/schema';



// =============================================================================

// MOCK EXTERNAL API (Placeholder for Google Calendar Integration)

// =============================================================================

const googleCalendarApi = {

Â  Â  async createEvent({ title, startTime, endTime, attendees }: { title: string, startTime: Date, endTime: Date, attendees: string[] }) {

Â  Â  Â  Â  console.log(`ğŸ“… Mock Google API: Creating event "${title}" for attendees: ${attendees.join(', ')}`);

Â  Â  Â  Â  // In a real app, this would use the Google Calendar API to create an event

Â  Â  Â  Â  // and would return the actual event details.

Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  Â  success: true,

Â  Â  Â  Â  Â  Â  htmlLink: `https://meet.google.com/new`, // Returns a generic link for simulation

Â  Â  Â  Â  Â  Â  googleEventId: `mock_event_${Date.now()}`

Â  Â  Â  Â  };

Â  Â  }

};



// Store Server-Sent Events connections

const sseConnections = new Map<string, Response>();



function notifyClientsOfNewMessage(messageRecord: any) {

Â  console.log(`ğŸ“¡ Notifying ${sseConnections.size} connected clients of new message`);

Â Â 

Â  const messageData = JSON.stringify({

Â  Â  type: 'new_message',

Â  Â  message: messageRecord

Â  });



Â  // Send to all connected SSE clients

Â  for (const [clientId, res] of sseConnections) {

Â  Â  try {

Â  Â  Â  res.write(`data: ${messageData}\n\n`);

Â  Â  Â  console.log(`ğŸ“¡ Sent message notification to client ${clientId}`);

Â  Â  } catch (error) {

Â  Â  Â  console.error(`ğŸ“¡ Error sending to client ${clientId}:`, error);

Â  Â  Â  // Remove broken connection

Â  Â  Â  sseConnections.delete(clientId);

Â  Â  }

Â  }

}



// =============================================================================

// WEBHOOK CONTROLLER LOGIC

// This object encapsulates all the logic for processing incoming webhooks.

// =============================================================================



export const WebhookController = {



Â  Â  // ... (handleIncomingEvent remains the same)

Â  Â Â 

Â  Â  /**

Â  Â  Â * The main entry point for all incoming webhooks from the Evolution API.

Â  Â  Â */

Â  Â  async handleIncomingEvent(req: Request, res: Response) {

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const instanceName = req.params.instanceName;

Â  Â  Â  Â  Â  Â  const eventType = req.params.eventType;

Â  Â  Â  Â  Â  Â  const eventPayload = req.body;

Â  Â  Â  Â  Â  Â  console.log(`ğŸ” Debug - instanceName: ${instanceName}, eventType: ${eventType}, req.path: ${req.path}`);

Â  Â  Â  Â  Â  Â  res.status(200).json({ status: "received", instance: instanceName });

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Extract event type from URL path if not in params

Â  Â  Â  Â  Â  Â  let actualEventType = eventType;

Â  Â  Â  Â  Â  Â  if (!actualEventType && req.path) {

Â  Â  Â  Â  Â  Â  Â  Â  const pathParts = req.path.split('/');

Â  Â  Â  Â  Â  Â  Â  Â  actualEventType = pathParts[pathParts.length - 1];

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Handle event type from URL parameter or path

Â  Â  Â  Â  Â  Â  if (actualEventType) {

Â  Â  Â  Â  Â  Â  Â  Â  const normalizedEventType = actualEventType.replace(/-/g, '.');

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ”„ Converting URL event type: ${actualEventType} -> ${normalizedEventType}`);

Â  Â  Â  Â  Â  Â  Â  Â  const wrappedEvent = {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  event: normalizedEventType,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data: eventPayload

Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  this.processEvolutionEvent(instanceName, wrappedEvent);

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  this.processEvolutionEvent(instanceName, eventPayload);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.error('âŒ Critical error in webhook handler:', error);

Â  Â  Â  Â  }

Â  Â  },

Â  Â Â 

Â  Â  /**

Â  Â  Â * NEW: Processes the bulk data from an initial API sync.

Â  Â  Â * This should be called from your REST API route that fetches initial data.

Â  Â  Â */

Â  Â  async processInitialChatSync(instanceId: string, chats: any[]) {

Â  Â  Â  Â  console.log(`ğŸ”„ Processing ${chats.length} conversations from initial sync for instance ${instanceId}`);

Â  Â  Â  Â  for (const rawChat of chats) {

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  const chatForDb = this.mapApiPayloadToWhatsappChat(rawChat, instanceId);

Â  Â  Â  Â  Â  Â  Â  Â  if (chatForDb) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await storage.upsertWhatsappChat(chatForDb);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Synced chat: ${chatForDb.chat_id}`);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.error(`âŒ Error syncing chat ${rawChat.id}:`, error);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Routes the event to the appropriate handler based on its type.

Â  Â  Â */

Â  Â  async processEvolutionEvent(instanceId: string, event: any) {

Â  Â  Â  Â  const { event: eventType, data, sender } = event; // `sender` is the reactor in reaction updates

Â  Â  Â  Â  console.log(`ğŸ“¨ Webhook Event Received: ${eventType} for instance ${instanceId}`);

Â  Â  Â  Â  console.log(`ğŸ” Full event structure:`, JSON.stringify({ eventType, dataType: typeof data, dataKeys: data ? Object.keys(data) : 'null', hasArray: Array.isArray(data) }, null, 2));



Â  Â  Â  Â  switch (eventType) {

Â  Â  Â  Â  Â  Â  case 'messages.upsert':

Â  Â  Â  Â  Â  Â  Â  Â  // Extract message data from nested Evolution API structure

Â  Â  Â  Â  Â  Â  Â  Â  let messageData = data;

Â  Â  Â  Â  Â  Â  Â  Â  if (data.data && !data.key) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageData = Array.isArray(data.data) ? data.data[0] : data.data;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â Â 



Â  Â  Â  Â  Â  Â  Â  Â  // Check for reactions first

Â  Â  Â  Â  Â  Â  Â  Â  if (messageData.key && messageData.message?.reactionMessage) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ¯ Detected reaction in messages.upsert`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Extract reactor JID with proper fallback logic

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let reactorJid = messageData.key.participant || messageData.key.remoteJid || sender;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If still no reactor JID, use a reasonable default based on the chat type

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!reactorJid) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reactorJid = messageData.key.fromMe ?Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (messageData.key.remoteJid || sender || `${instanceId}@owner`) :

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (messageData.key.remoteJid || sender || `${instanceId}@participant`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleReaction(instanceId, messageData, reactorJid);

Â  Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleMessageUpsert(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'messages.update':

Â  Â  Â  Â  Â  Â  Â  Â  // Extract update data from nested Evolution API structure

Â  Â  Â  Â  Â  Â  Â  Â  let updateData = data;

Â  Â  Â  Â  Â  Â  Â  Â  if (data.data && !data.updates && !data.messageId) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateData = data.data;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  // Check for reactions in updates

Â  Â  Â  Â  Â  Â  Â  Â  if (updateData.updates && updateData.updates[0]?.message?.reactionMessage) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ¯ Detected reaction in messages.update (updates array)`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let reactorJid = updateData.updates[0].key?.participant || updateData.updates[0].key?.remoteJid || sender;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If still no reactor JID, use a reasonable default

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!reactorJid) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reactorJid = updateData.updates[0].key?.fromMe ?Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (updateData.updates[0].key?.remoteJid || sender || `${instanceId}@owner`) :

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (updateData.updates[0].key?.remoteJid || sender || `${instanceId}@participant`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleReaction(instanceId, updateData.updates[0], reactorJid);

Â  Â  Â  Â  Â  Â  Â  Â  } else if (updateData.message?.reactionMessage) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ¯ Detected direct reaction in messages.update`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Extract reactor JID with same logic as messages.upsert

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let reactorJid = updateData.key?.participant || updateData.key?.remoteJid || sender;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If still no reactor JID, use a reasonable default based on the chat type

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!reactorJid) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reactorJid = updateData.key?.fromMe ?Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (updateData.key?.remoteJid || sender || `${instanceId}@owner`) :

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (updateData.key?.remoteJid || sender || `${instanceId}@participant`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleReaction(instanceId, updateData, reactorJid);

Â  Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleMessageUpdate(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'messages.edit':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleMessageEdit(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'messages.delete':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleMessageDeletion(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'contacts.upsert':

Â  Â  Â  Â  Â  Â  case 'contacts.update':

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ‘¤ Contact event data:`, JSON.stringify(data, null, 2));

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleContactsUpsert(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'chats.upsert':

Â  Â  Â  Â  Â  Â  case 'chats.update':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleChatsUpsert(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'groups.upsert':

Â  Â  Â  Â  Â  Â  case 'groups.update':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleGroupsUpsert(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'connection.update':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleConnectionUpdate(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'group.participants.update':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleGroupParticipantsUpdate(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'labels.edit':

Â  Â  Â  Â  Â  Â  case 'labels.association':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleLabelsUpdate(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'chats.set':

Â  Â  Â  Â  Â  Â  case 'chats.delete':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleChatLabelsUpdate(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case 'call':

Â  Â  Â  Â  Â  Â  Â  Â  await this.handleCallLogs(instanceId, data);

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  default:

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`- Unhandled event type: ${eventType}`);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles incoming messages from the webhook.

Â  Â  Â */

Â  Â  async handleMessageUpsert(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ“ Processing message upsert for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract message data from nested Evolution API structure

Â  Â  Â  Â  let messageData = data;

Â  Â  Â  Â  if (data.data && !data.key) {

Â  Â  Â  Â  Â  Â  messageData = Array.isArray(data.data) ? data.data[0] : data.data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!messageData || !messageData.key || !messageData.key.id) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid message data found in webhook payload');

Â  Â  Â  Â  Â  Â  console.log('ğŸ” Available data keys:', data ? Object.keys(data) : 'none');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  const chatId = messageData.key.remoteJid;

Â  Â  Â  Â  const senderJid = messageData.key.fromMe ? instanceId : (messageData.key.participant || messageData.key.remoteJid);

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // 1. First ensure contact exists for the sender

Â  Â  Â  Â  Â  Â  const contactData = {

Â  Â  Â  Â  Â  Â  Â  Â  jid: senderJid,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  pushName: messageData.key.fromMe ? 'Me' : (messageData.pushName || ''),

Â  Â  Â  Â  Â  Â  Â  Â  profilePictureUrl: null,

Â  Â  Â  Â  Â  Â  Â  Â  isBusiness: false,

Â  Â  Â  Â  Â  Â  Â  Â  isMe: messageData.key.fromMe,

Â  Â  Â  Â  Â  Â  Â  Â  isBlocked: false

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappContact(contactData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created contact: ${senderJid}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  // Contact might already exist, try to update it instead

Â  Â  Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await storage.updateWhatsappContact(senderJid, instanceId, contactData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Contact ${senderJid} updated`);

Â  Â  Â  Â  Â  Â  Â  Â  } catch (updateError) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Contact ${senderJid} exists, proceeding`);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // 2. Then ensure chat exists

Â  Â  Â  Â  Â  Â  const chatData = {

Â  Â  Â  Â  Â  Â  Â  Â  chatId: chatId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  type: chatId.includes('@g.us') ? 'group' : 'individual',

Â  Â  Â  Â  Â  Â  Â  Â  unreadCount: 0,

Â  Â  Â  Â  Â  Â  Â  Â  isArchived: false,

Â  Â  Â  Â  Â  Â  Â  Â  isPinned: false,

Â  Â  Â  Â  Â  Â  Â  Â  isMuted: false,

Â  Â  Â  Â  Â  Â  Â  Â  lastMessageTimestamp: new Date(messageData.messageTimestamp * 1000)

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappChat(chatData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created chat: ${chatId}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  // Chat might already exist

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Chat ${chatId} already exists`);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // 3. Finally create the message with all dependencies satisfied

Â  Â  Â  Â  Â  Â  const messageForDb = this.mapApiPayloadToWhatsappMessage(messageData, instanceId);

Â  Â  Â  Â  Â  Â  if (messageForDb) {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.upsertWhatsappMessage(messageForDb);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Saved/Updated message: ${messageForDb.message_id}`);

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  // 4. Process actions engine for this message

Â  Â  Â  Â  Â  Â  Â  Â  await this.processMessageForActions(messageForDb, instanceId);

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  if (messageForDb.quoted_message_id) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await this.handleReplyToContextMessage(instanceId, messageForDb);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.error(`âŒ Error processing message ${messageData.key.id}:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Process message for automated actions

Â  Â  Â */

Â  Â  async processMessageForActions(message: any, instanceId?: string) {

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const { ActionsEngine } = await import('./actions-engine');

Â  Â  Â  Â  Â  Â  const { hashtags, keywords } = ActionsEngine.extractHashtagsAndKeywords(message.content || '');

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const triggerContext = {

Â  Â  Â  Â  Â  Â  Â  Â  messageId: message.messageId || message.message_id,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId || message.instanceId || message.instance_id,

Â  Â  Â  Â  Â  Â  Â  Â  chatId: message.chatId || message.chat_id,

Â  Â  Â  Â  Â  Â  Â  Â  senderJid: message.senderJid || message.sender_jid,

Â  Â  Â  Â  Â  Â  Â  Â  content: message.content || '',

Â  Â  Â  Â  Â  Â  Â  Â  hashtags,

Â  Â  Â  Â  Â  Â  Â  Â  keywords,

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date(message.timestamp),

Â  Â  Â  Â  Â  Â  Â  Â  fromMe: message.fromMe || message.from_me || false

Â  Â  Â  Â  Â  Â  };



Â  Â  Â  Â  Â  Â  console.log('ğŸ¯ Action context prepared:', {

Â  Â  Â  Â  Â  Â  Â  Â  messageId: triggerContext.messageId,

Â  Â  Â  Â  Â  Â  Â  Â  hashtags: triggerContext.hashtags,

Â  Â  Â  Â  Â  Â  Â  Â  content: triggerContext.content.substring(0, 50) + '...'

Â  Â  Â  Â  Â  Â  });



Â  Â  Â  Â  Â  Â  await ActionsEngine.processMessageForActions(triggerContext);

Â  Â  Â  Â  Â  Â  console.log(`âœ… Processed message for automated actions`);

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.error('âŒ Error processing message for actions:', error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Maps Evolution API message payload to WhatsApp message structure

Â  Â  Â */

Â  Â  mapApiPayloadToWhatsappMessage(rawMessage: any, instanceId: string) {

Â  Â  Â  Â  if (!rawMessage.key || !rawMessage.key.id) return null;



Â  Â  Â  Â  const key = rawMessage.key;

Â  Â  Â  Â  const message = rawMessage.message;



Â  Â  Â  Â  // Extract message content and determine type using comprehensive mapping

Â  Â  Â  Â  const { content, messageType } = this.extractMessageContentAndType(message);



Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  Â  message_id: key.id,

Â  Â  Â  Â  Â  Â  instance_id: instanceId,

Â  Â  Â  Â  Â  Â  chat_id: key.remoteJid,

Â  Â  Â  Â  Â  Â  sender_jid: key.fromMe ? instanceId : (key.participant || key.remoteJid),

Â  Â  Â  Â  Â  Â  from_me: key.fromMe,

Â  Â  Â  Â  Â  Â  message_type: messageType,

Â  Â  Â  Â  Â  Â  content: content,

Â  Â  Â  Â  Â  Â  timestamp: new Date(rawMessage.messageTimestamp * 1000),

Â  Â  Â  Â  Â  Â  quoted_message_id: null,

Â  Â  Â  Â  Â  Â  is_forwarded: false,

Â  Â  Â  Â  Â  Â  forwarding_score: 0,

Â  Â  Â  Â  Â  Â  is_starred: false,

Â  Â  Â  Â  Â  Â  is_edited: false,

Â  Â  Â  Â  Â  Â  source_platform: rawMessage.source || 'android',

Â  Â  Â  Â  Â  Â  raw_api_payload: rawMessage

Â  Â  Â  Â  };

Â  Â  },



Â  Â  /**

Â  Â  Â * Handle replies to context messages

Â  Â  Â */

Â  Â  async handleReplyToContextMessage(instanceId: string, messageForDb: any) {

Â  Â  Â  Â  // Implementation for handling replies to context messages

Â  Â  Â  Â  console.log(`ğŸ”— Processing reply context for message ${messageForDb.message_id}`);

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles message updates (status changes, reactions, etc.)

Â  Â  Â */

Â  Â  async handleMessageUpdate(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ“ Processing message update for instance ${instanceId}`, JSON.stringify(data, null, 2));

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Evolution API can send updates in different formats

Â  Â  Â  Â  let updates = [];

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (data.update) {

Â  Â  Â  Â  Â  Â  updates = Array.isArray(data.update) ? data.update : [data.update];

Â  Â  Â  Â  } else if (data.key && data.status) {

Â  Â  Â  Â  Â  Â  // Direct update format with key structure

Â  Â  Â  Â  Â  Â  updates = [data];

Â  Â  Â  Â  } else if (data.data && (data.data.keyId || data.data.messageId || data.data.status)) {

Â  Â  Â  Â  Â  Â  // Evolution API wrapped format

Â  Â  Â  Â  Â  Â  updates = [data.data];

Â  Â  Â  Â  } else if (data.keyId || data.messageId || data.status) {

Â  Â  Â  Â  Â  Â  // Evolution API direct format

Â  Â  Â  Â  Â  Â  updates = [data];

Â  Â  Â  Â  } else if (Array.isArray(data)) {

Â  Â  Â  Â  Â  Â  // Array of updates

Â  Â  Â  Â  Â  Â  updates = data;

Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid message update data found in webhook payload');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  for (const update of updates) {

Â  Â  Â  Â  Â  Â  // Handle different message ID formats from Evolution API

Â  Â  Â  Â  Â  Â  let messageId = null;

Â  Â  Â  Â  Â  Â  if (update.key?.id) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = update.key.id;

Â  Â  Â  Â  Â  Â  } else if (update.keyId) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = update.keyId;

Â  Â  Â  Â  Â  Â  } else if (update.messageId) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = update.messageId;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  if (!messageId || !update.status) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log('âš ï¸ Message update missing required messageId or status');

Â  Â  Â  Â  Â  Â  Â  Â  continue;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const status = update.status;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Map Evolution API status to our enum values

Â  Â  Â  Â  Â  Â  const mappedStatus = this.mapMessageStatus(status);

Â  Â  Â  Â  Â  Â  if (!mappedStatus) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âš ï¸ Unknown message status: ${status}`);

Â  Â  Â  Â  Â  Â  Â  Â  continue;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const updateRecord = {

Â  Â  Â  Â  Â  Â  Â  Â  messageId: messageId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  status: mappedStatus,

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date(update.messageTimestamp * 1000 || Date.now())

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappMessageUpdate(updateRecord);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored message update: ${messageId} -> ${mappedStatus}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing message update:`, error);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âŒ Update record was:`, updateRecord);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Maps Evolution API message status to our database enum values

Â  Â  Â */

Â  Â  mapMessageStatus(apiStatus: string): string | null {

Â  Â  Â  Â  const statusMap: { [key: string]: string } = {

Â  Â  Â  Â  Â  Â  'ERROR': 'error',

Â  Â  Â  Â  Â  Â  'PENDING': 'pending',Â 

Â  Â  Â  Â  Â  Â  'SERVER_ACK': 'sent',

Â  Â  Â  Â  Â  Â  'DELIVERY_ACK': 'delivered',

Â  Â  Â  Â  Â  Â  'READ': 'read',

Â  Â  Â  Â  Â  Â  'PLAYED': 'played'

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  return statusMap[apiStatus] || null;

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles contact updates from the webhook.

Â  Â  Â */

Â  Â  async handleContactsUpsert(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ‘¤ Processing contacts upsert for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Evolution API can send contacts in different formats

Â  Â  Â  Â  let contacts = [];

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Debug the data structure

Â  Â  Â  Â  console.log(`ğŸ” Contact data structure: hasData=${!!data.data}, isDataArray=${Array.isArray(data.data)}, dataType=${typeof data.data}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (data.data && Array.isArray(data.data)) {

Â  Â  Â  Â  Â  Â  // Array of contacts in data.data

Â  Â  Â  Â  Â  Â  contacts = data.data;

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“‹ Found ${contacts.length} contacts in data.data array`);

Â  Â  Â  Â  } else if (data.data && typeof data.data === 'object' && (data.data.remoteJid || data.data.id || data.data.jid)) {

Â  Â  Â  Â  Â  Â  // Single contact object in data.data

Â  Â  Â  Â  Â  Â  contacts = [data.data];

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“„ Found single contact in data.data: ${data.data.remoteJid || data.data.id || data.data.jid}`);

Â  Â  Â  Â  } else if (Array.isArray(data)) {

Â  Â  Â  Â  Â  Â  // Direct array of contacts

Â  Â  Â  Â  Â  Â  contacts = data;

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“‹ Found ${contacts.length} contacts in root array`);

Â  Â  Â  Â  } else if (data.data && data.data.contacts) {

Â  Â  Â  Â  Â  Â  // Contacts nested in data.data.contacts

Â  Â  Â  Â  Â  Â  contacts = Array.isArray(data.data.contacts) ? data.data.contacts : [data.data.contacts];

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“‹ Found contacts in data.data.contacts`);

Â  Â  Â  Â  } else if (data.contacts) {

Â  Â  Â  Â  Â  Â  // Contacts nested in data.contacts

Â  Â  Â  Â  Â  Â  contacts = Array.isArray(data.contacts) ? data.contacts : [data.contacts];

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“‹ Found contacts in data.contacts`);

Â  Â  Â  Â  } else if (data.id || data.jid || data.pushName || data.remoteJid) {

Â  Â  Â  Â  Â  Â  // Single contact at root level

Â  Â  Â  Â  Â  Â  contacts = [data];

Â  Â  Â  Â  Â  Â  console.log(`ğŸ“„ Found single contact at root level`);

Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid contact data found in webhook payload');

Â  Â  Â  Â  Â  Â  console.log('ğŸ” Available keys:', Object.keys(data || {}));

Â  Â  Â  Â  Â  Â  if (data.data) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log('ğŸ” data.data keys:', Object.keys(data.data || {}));

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  for (const rawContact of contacts) {

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  // Extract contact JID from different possible fields

Â  Â  Â  Â  Â  Â  Â  Â  const jid = rawContact.remoteJid || rawContact.id || rawContact.jid;

Â  Â  Â  Â  Â  Â  Â  Â  if (!jid) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log('âš ï¸ Contact missing required JID');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  const contactData = {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jid: jid,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pushName: rawContact.pushName || rawContact.push_name || rawContact.name || rawContact.notify || null,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  verifiedName: rawContact.verifiedName || rawContact.verified_name || null,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  profilePictureUrl: rawContact.profilePicUrl || rawContact.profilePictureUrl || rawContact.profile_picture_url || null,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isBusiness: rawContact.isBusiness || rawContact.is_business || false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMe: rawContact.isMe || rawContact.is_me || false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isBlocked: rawContact.isBlocked || rawContact.is_blocked || false

Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappContact(contactData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created/Updated contact: ${contactData.jid} (${contactData.pushName || 'No name'})`);

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âŒ Contact processing error:`, error);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles chat/conversation updates from the webhook.

Â  Â  Â */

Â  Â  async handleChatsUpsert(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ’¬ Processing chats upsert for instance ${instanceId}:`, data);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract chat data from nested Evolution API structure

Â  Â  Â  Â  let chats = [];

Â  Â  Â  Â  if (data && data.data && Array.isArray(data.data)) {

Â  Â  Â  Â  Â  Â  chats = data.data;

Â  Â  Â  Â  } else if (Array.isArray(data)) {

Â  Â  Â  Â  Â  Â  chats = data;

Â  Â  Â  Â  } else if (data && data.data && !Array.isArray(data.data)) {

Â  Â  Â  Â  Â  Â  chats = [data.data];

Â  Â  Â  Â  } else if (data && (data.remoteJid || data.id)) {

Â  Â  Â  Â  Â  Â  chats = [data];

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  console.log(`ğŸ” Extracted ${chats.length} chats from payload`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (chats.length === 0) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid chat data found in webhook payload');

Â  Â  Â  Â  Â  Â  console.log('ğŸ” Available data keys:', data ? Object.keys(data) : 'none');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  for (const rawChat of chats) {

Â  Â  Â  Â  Â  Â  if (!rawChat.id && !rawChat.remoteJid) continue;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const chatId = rawChat.id || rawChat.remoteJid;

Â  Â  Â  Â  Â  Â  const chatData = {

Â  Â  Â  Â  Â  Â  Â  Â  chatId: chatId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  type: chatId.includes('@g.us') ? 'group' : 'individual',

Â  Â  Â  Â  Â  Â  Â  Â  unreadCount: rawChat.unreadMessages || rawChat.unreadCount || 0,

Â  Â  Â  Â  Â  Â  Â  Â  isArchived: rawChat.archived || rawChat.isArchived || false,

Â  Â  Â  Â  Â  Â  Â  Â  isPinned: rawChat.pinned || rawChat.isPinned || false,

Â  Â  Â  Â  Â  Â  Â  Â  isMuted: rawChat.muted || rawChat.isMuted || false,

Â  Â  Â  Â  Â  Â  Â  Â  lastMessageTimestamp: rawChat.lastMessage?.messageTimestamp ?Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new Date(rawChat.lastMessage.messageTimestamp * 1000) : null

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappChat(chatData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created/Updated chat: ${chatData.chatId}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Chat ${chatData.chatId} processing error:`, error.message);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Comprehensive message content extraction with proper type mapping

Â  Â  Â */

Â  Â  extractMessageContentAndType(message: any): { content: string; messageType: string } {

Â  Â  Â  Â  if (!message) return { content: '', messageType: 'unsupported' };



Â  Â  Â  Â  // Text messages

Â  Â  Â  Â  if (message.conversation) {

Â  Â  Â  Â  Â  Â  return { content: message.conversation, messageType: 'text' };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.extendedTextMessage?.text) {

Â  Â  Â  Â  Â  Â  return { content: message.extendedTextMessage.text, messageType: 'text' };

Â  Â  Â  Â  }



Â  Â  Â  Â  // Media messages with captions

Â  Â  Â  Â  if (message.imageMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: message.imageMessage.caption || '[Image]',Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'image'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.videoMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: message.videoMessage.caption || '[Video]',Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'video'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.audioMessage) {

Â  Â  Â  Â  Â  Â  return { content: '[Audio]', messageType: 'audio' };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.documentMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: message.documentMessage.caption || `[Document: ${message.documentMessage.fileName || 'file'}]`,Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'document'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }



Â  Â  Â  Â  // Special message types

Â  Â  Â  Â  if (message.stickerMessage) {

Â  Â  Â  Â  Â  Â  return { content: '[Sticker]', messageType: 'sticker' };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.locationMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: `[Location: ${message.locationMessage.name || 'Unknown location'}]`,Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'location'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.contactMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: `[Contact: ${message.contactMessage.displayName || 'Unknown contact'}]`,Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'contact_card'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.contactsArrayMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: `[Contacts: ${message.contactsArrayMessage.contacts?.length || 0} contacts]`,Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'contact_card_multi'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }



Â  Â  Â  Â  // System/control messages

Â  Â  Â  Â  if (message.protocolMessage) {

Â  Â  Â  Â  Â  Â  if (message.protocolMessage.type === 'REVOKE') {

Â  Â  Â  Â  Â  Â  Â  Â  return { content: 'This message was deleted', messageType: 'revoked' };

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  if (message.reactionMessage) {

Â  Â  Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  Â  Â  content: `Reacted with ${message.reactionMessage.text}`,Â 

Â  Â  Â  Â  Â  Â  Â  Â  messageType: 'reaction'Â 

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }



Â  Â  Â  Â  // Fallback for unknown message types

Â  Â  Â  Â  return { content: '[Unsupported message type]', messageType: 'unsupported' };

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles message edits from Evolution API

Â  Â  Â */

Â  Â  async handleMessageEdit(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`âœï¸ Processing message edit for instance ${instanceId}`, JSON.stringify(data, null, 2));

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract edit data from different possible formats

Â  Â  Â  Â  let editData = null;

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (data.data) {

Â  Â  Â  Â  Â  Â  editData = data.data;

Â  Â  Â  Â  } else if (data.keyId || data.messageId) {

Â  Â  Â  Â  Â  Â  editData = data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!editData) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid message edit data found in webhook payload');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // Extract message ID

Â  Â  Â  Â  Â  Â  const messageId = editData.keyId || editData.messageId;

Â  Â  Â  Â  Â  Â  if (!messageId) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log('âš ï¸ Message edit missing required message ID');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Extract edited content

Â  Â  Â  Â  Â  Â  let editedContent = '';

Â  Â  Â  Â  Â  Â  if (editData.editedMessage?.conversation) {

Â  Â  Â  Â  Â  Â  Â  Â  editedContent = editData.editedMessage.conversation;

Â  Â  Â  Â  Â  Â  } else if (editData.newText) {

Â  Â  Â  Â  Â  Â  Â  Â  editedContent = editData.newText;

Â  Â  Â  Â  Â  Â  } else if (editData.content) {

Â  Â  Â  Â  Â  Â  Â  Â  editedContent = editData.content;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Extract original content

Â  Â  Â  Â  Â  Â  let originalContent = '';

Â  Â  Â  Â  Â  Â  if (editData.originalMessage?.conversation) {

Â  Â  Â  Â  Â  Â  Â  Â  originalContent = editData.originalMessage.conversation;

Â  Â  Â  Â  Â  Â  } else if (editData.oldText) {

Â  Â  Â  Â  Â  Â  Â  Â  originalContent = editData.oldText;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const editTimestamp = new Date(editData.editTimestamp * 1000 || Date.now());

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Step 1: Store the original content in edit history for audit trail

Â  Â  Â  Â  Â  Â  const editRecord = {

Â  Â  Â  Â  Â  Â  Â  Â  messageId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  oldContent: originalContent,

Â  Â  Â  Â  Â  Â  Â  Â  editTimestamp

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  await storage.createWhatsappMessageEditHistory(editRecord);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Step 2: Update the actual message content with the new edited content

Â  Â  Â  Â  Â  Â  if (editedContent) {

Â  Â  Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await storage.updateWhatsappMessageContent({

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  messageId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newContent: editedContent,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isEdited: true,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastEditedAt: editTimestamp

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Updated message content and stored edit history: ${messageId}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Content updated to: "${editedContent}"`);

Â  Â  Â  Â  Â  Â  Â  Â  } catch (updateError) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âŒ Error updating message content:`, updateError);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored edit history only: ${messageId}`);

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored message edit history: ${messageId} (no new content provided)`);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing message edit:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles message deletions from Evolution API

Â  Â  Â */

Â  Â  async handleMessageDeletion(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ—‘ï¸ Processing message deletion for instance ${instanceId}`, JSON.stringify(data, null, 2));

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract deletion data from different possible formats

Â  Â  Â  Â  let deletionData = null;

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (data.data) {

Â  Â  Â  Â  Â  Â  deletionData = data.data;

Â  Â  Â  Â  } else if (data.keyId || data.messageId || data.key) {

Â  Â  Â  Â  Â  Â  deletionData = data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!deletionData) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid message deletion data found in webhook payload');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // Extract message ID from different formats

Â  Â  Â  Â  Â  Â  let messageId = null;

Â  Â  Â  Â  Â  Â  if (deletionData.key?.id) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = deletionData.key.id;

Â  Â  Â  Â  Â  Â  } else if (deletionData.keyId) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = deletionData.keyId;

Â  Â  Â  Â  Â  Â  } else if (deletionData.messageId) {

Â  Â  Â  Â  Â  Â  Â  Â  messageId = deletionData.messageId;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  if (!messageId) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log('âš ï¸ Message deletion missing required message ID');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Extract chat ID

Â  Â  Â  Â  Â  Â  const chatId = deletionData.remoteJid || deletionData.key?.remoteJid || deletionData.chatId;

Â  Â  Â  Â  Â  Â  if (!chatId) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log('âš ï¸ Message deletion missing required chat ID');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Extract who deleted the message

Â  Â  Â  Â  Â  Â  const deletedBy = deletionData.participant || deletionData.deletedBy || deletionData.key?.participant || 'unknown';

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Determine deletion type

Â  Â  Â  Â  Â  Â  let deletionType = 'sender'; // default

Â  Â  Â  Â  Â  Â  if (deletionData.deletionType) {

Â  Â  Â  Â  Â  Â  Â  Â  deletionType = deletionData.deletionType;

Â  Â  Â  Â  Â  Â  } else if (deletionData.key?.fromMe) {

Â  Â  Â  Â  Â  Â  Â  Â  deletionType = 'sender';

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  deletionType = 'everyone';

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Get original content if available

Â  Â  Â  Â  Â  Â  const originalContent = deletionData.originalContent || deletionData.content || null;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const deletionRecord = {

Â  Â  Â  Â  Â  Â  Â  Â  deletionId: `${messageId}_${Date.now()}`,

Â  Â  Â  Â  Â  Â  Â  Â  messageId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  chatId,

Â  Â  Â  Â  Â  Â  Â  Â  deletedBy,

Â  Â  Â  Â  Â  Â  Â  Â  deletionType,

Â  Â  Â  Â  Â  Â  Â  Â  originalContent,

Â  Â  Â  Â  Â  Â  Â  Â  originalTimestamp: deletionData.messageTimestamp ? new Date(deletionData.messageTimestamp * 1000) : null,

Â  Â  Â  Â  Â  Â  Â  Â  deletedAt: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  rawApiPayload: deletionData

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  await storage.createWhatsappMessageDeletion(deletionRecord);

Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored message deletion: ${messageId} by ${deletedBy}`);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing message deletion:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles connection status updates.

Â  Â  Â */

Â  Â  async handleConnectionUpdate(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ”— Processing connection update for instance ${instanceId}`);

Â  Â  Â  Â  // Implementation for connection updates

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles a reaction event.

Â  Â  Â */

Â  Â  async handleReaction(instanceId: string, reactionData: any, reactorJid: string) {

Â  Â  Â  Â  const reactionMessage = reactionData.message.reactionMessage;

Â  Â  Â  Â  const reactionEmoji = reactionMessage.text;

Â  Â  Â  Â  const targetMessageId = reactionMessage.key.id;

Â  Â  Â  Â  const targetChatId = reactionMessage.key.remoteJid;



Â  Â  Â  Â  console.log(`ğŸ‘ Reaction '${reactionEmoji}' on message ${targetMessageId} by ${reactorJid}`);



Â  Â  Â  Â  // Store the reaction in the message_reactions table

Â  Â  Â  Â  const reactionRecord = {

Â  Â  Â  Â  Â  Â  messageId: targetMessageId,

Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  reactorJid: reactorJid,

Â  Â  Â  Â  Â  Â  reactionEmoji: reactionEmoji,

Â  Â  Â  Â  Â  Â  fromMe: reactionData.key.fromMe || false,

Â  Â  Â  Â  Â  Â  timestamp: new Date(reactionData.messageTimestamp * 1000 || Date.now())

Â  Â  Â  Â  };



Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  await storage.createWhatsappMessageReaction(reactionRecord);

Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored reaction: ${reactionEmoji} by ${reactorJid} on ${targetMessageId}`);

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing reaction:`, error);

Â  Â  Â  Â  Â  Â  console.log(`âŒ Reaction record was:`, reactionRecord);

Â  Â  Â  Â  }



Â  Â  Â  Â  // Also trigger any configured actions with rich context

Â  Â  Â  Â  const actionContext = {

Â  Â  Â  Â  Â  Â  messageId: targetMessageId,

Â  Â  Â  Â  Â  Â  reactorJid: reactorJid,

Â  Â  Â  Â  Â  Â  chatId: targetChatId,

Â  Â  Â  Â  Â  Â  messageContent: '', // Will be populated if available

Â  Â  Â  Â  Â  Â  reactionEmoji: reactionEmoji,

Â  Â  Â  Â  Â  Â  timestamp: reactionRecord.timestamp

Â  Â  Â  Â  };

Â  Â  Â  Â  await this.triggerAction(instanceId, 'reaction', reactionEmoji, actionContext);

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles group updates from the webhook.

Â  Â  Â */

Â  Â  async handleGroupsUpsert(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ‘¥ Processing groups upsert for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!data || !Array.isArray(data)) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid group data found in webhook payload');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  for (const rawGroup of data) {

Â  Â  Â  Â  Â  Â  if (!rawGroup.id && !rawGroup.remoteJid) continue;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const groupId = rawGroup.id || rawGroup.remoteJid;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // First ensure the group exists as a chat

Â  Â  Â  Â  Â  Â  const chatData = {

Â  Â  Â  Â  Â  Â  Â  Â  chatId: groupId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  type: 'group',

Â  Â  Â  Â  Â  Â  Â  Â  unreadCount: rawGroup.unreadMessages || rawGroup.unreadCount || 0,

Â  Â  Â  Â  Â  Â  Â  Â  isArchived: rawGroup.archived || false,

Â  Â  Â  Â  Â  Â  Â  Â  isPinned: rawGroup.pinned || false,

Â  Â  Â  Â  Â  Â  Â  Â  isMuted: rawGroup.muted || false,

Â  Â  Â  Â  Â  Â  Â  Â  lastMessageTimestamp: rawGroup.lastMessage?.messageTimestamp ?Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new Date(rawGroup.lastMessage.messageTimestamp * 1000) : null

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappChat(chatData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created/Updated group chat: ${groupId}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Group chat ${groupId} already exists or error:`, error.message);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Create the actual group record in the groups table

Â  Â  Â  Â  Â  Â  const groupData = {

Â  Â  Â  Â  Â  Â  Â  Â  groupJid: groupId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  subject: rawGroup.subject || rawGroup.name || '',

Â  Â  Â  Â  Â  Â  Â  Â  description: rawGroup.desc || rawGroup.description || null,

Â  Â  Â  Â  Â  Â  Â  Â  ownerJid: rawGroup.owner || null,

Â  Â  Â  Â  Â  Â  Â  Â  creationTimestamp: rawGroup.creation ? new Date(rawGroup.creation * 1000) : null,

Â  Â  Â  Â  Â  Â  Â  Â  isLocked: rawGroup.restrict || false

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappGroup(groupData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created/Updated group: ${groupId} - ${groupData.subject}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Group ${groupId} creation error:`, error.message);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Process group participants if available

Â  Â  Â  Â  Â  Â  if (rawGroup.participants) {

Â  Â  Â  Â  Â  Â  Â  Â  for (const participant of rawGroup.participants) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const participantJid = participant.id || participant.jid;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // First create contact record for participant

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const contactData = {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jid: participantJid,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pushName: participant.notify || participant.name || '',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  profilePictureUrl: null,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isBusiness: false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMe: false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isBlocked: false

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappContact(contactData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created group participant contact: ${participantJid}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Contact might already exist

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Group participant contact ${participantJid} already exists`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Then create group participant record

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const groupParticipantData = {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groupJid: groupId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  participantJid: participantJid,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAdmin: participant.admin === 'admin' || participant.admin === 'superadmin',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSuperAdmin: participant.admin === 'superadmin'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappGroupParticipant(groupParticipantData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Created group participant: ${participantJid} (${participant.admin || 'member'})`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“ Group participant ${participantJid} already exists`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles group participant updates from the webhook.

Â  Â  Â */

Â  Â  async handleGroupParticipantsUpdate(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ‘¥ Processing group participants update for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract participant data from nested structure

Â  Â  Â  Â  let participantData = data;

Â  Â  Â  Â  if (data.data && !data.participants) {

Â  Â  Â  Â  Â  Â  participantData = data.data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!participantData.participants || !participantData.groupId) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid group participant data found');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Store group participant changes in database

Â  Â  Â  Â  for (const participant of participantData.participants) {

Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  Â  const groupParticipantData = {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  groupJid: participantData.groupId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  participantJid: participant,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isAdmin: false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSuperAdmin: false,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  action: participantData.action || 'unknown',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rawPayload: JSON.stringify(data)

Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  await storage.createWhatsappGroupParticipant(groupParticipantData);

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored group participant update: ${participant} ${participantData.action} in ${participantData.groupId}`);

Â  Â  Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing group participant update:`, error);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles label updates from the webhook.

Â  Â  Â */

Â  Â  async handleLabelsUpdate(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ·ï¸ Processing labels update for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract label data from nested structure

Â  Â  Â  Â  let labelData = data;

Â  Â  Â  Â  if (data.data && !data.labelId) {

Â  Â  Â  Â  Â  Â  labelData = data.data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!labelData.labelId) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid label data found');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const labelUpdateData = {

Â  Â  Â  Â  Â  Â  Â  Â  labelId: labelData.labelId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  name: labelData.name || '',

Â  Â  Â  Â  Â  Â  Â  Â  color: labelData.color || null,

Â  Â  Â  Â  Â  Â  Â  Â  action: labelData.action || 'update',

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  rawPayload: JSON.stringify(data)

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  await storage.createWhatsappLabel(labelUpdateData);

Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored label update: ${labelData.labelId}`);

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing label update:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles chat label updates from the webhook.

Â  Â  Â */

Â  Â  async handleChatLabelsUpdate(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ·ï¸ğŸ’¬ Processing chat labels update for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract chat label data from nested structure

Â  Â  Â  Â  let chatLabelData = data;

Â  Â  Â  Â  if (data.data && !data.chatId) {

Â  Â  Â  Â  Â  Â  chatLabelData = data.data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!chatLabelData.chatId) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid chat label data found');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const chatLabelUpdateData = {

Â  Â  Â  Â  Â  Â  Â  Â  chatId: chatLabelData.chatId,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  labelIds: chatLabelData.labelIds || [],

Â  Â  Â  Â  Â  Â  Â  Â  action: chatLabelData.action || 'set',

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  rawPayload: JSON.stringify(data)

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  await storage.createWhatsappChatLabel(chatLabelUpdateData);

Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored chat label update: ${chatLabelData.chatId}`);

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing chat label update:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Handles call logs from the webhook.

Â  Â  Â */

Â  Â  async handleCallLogs(instanceId: string, data: any) {

Â  Â  Â  Â  console.log(`ğŸ“ Processing call logs for instance ${instanceId}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Extract call data from nested structure

Â  Â  Â  Â  let callData = data;

Â  Â  Â  Â  if (data.data && !data.callId) {

Â  Â  Â  Â  Â  Â  callData = data.data;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  if (!callData.callId && !callData.id) {

Â  Â  Â  Â  Â  Â  console.log('âš ï¸ No valid call data found');

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  const callLogData = {

Â  Â  Â  Â  Â  Â  Â  Â  callId: callData.callId || callData.id,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId: instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  fromJid: callData.from || callData.fromJid,

Â  Â  Â  Â  Â  Â  Â  Â  toJid: callData.to || callData.toJid,

Â  Â  Â  Â  Â  Â  Â  Â  status: callData.status || 'unknown',

Â  Â  Â  Â  Â  Â  Â  Â  duration: callData.duration || 0,

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: callData.timestamp ? new Date(callData.timestamp * 1000) : new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  isVideo: callData.isVideo || false,

Â  Â  Â  Â  Â  Â  Â  Â  rawPayload: JSON.stringify(data)

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  await storage.createWhatsappCallLog(callLogData);

Â  Â  Â  Â  Â  Â  console.log(`âœ… [${instanceId}] Stored call log: ${callLogData.callId}`);

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error storing call log:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Central action trigger logic.

Â  Â  Â */

Â  Â  async triggerAction(instanceId: string, triggerType: 'reaction' | 'hashtag', triggerValue: string, context: { messageId: string, reactorJid: string }) {

Â  Â  Â  Â  console.log(`ğŸ”„ Trigger action: ${triggerType} -> ${triggerValue}`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // Query active action rules that match the trigger type

Â  Â  Â  Â  Â  Â  const matchingRules = await storage.getMatchingActionRules(triggerType, triggerValue, instanceId);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  if (matchingRules.length === 0) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“­ No matching action rules found for ${triggerType}: ${triggerValue}`);

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  console.log(`ğŸ¯ Found ${matchingRules.length} matching action rule(s)`);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Execute each matching rule

Â  Â  Â  Â  Â  Â  for (const rule of matchingRules) {

Â  Â  Â  Â  Â  Â  Â  Â  await this.executeActionRule(rule, triggerType, triggerValue, context, instanceId);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  console.log(`âŒ Error processing action triggers:`, error);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute a specific action rule

Â  Â  Â */

Â  Â  async executeActionRule(rule: any, triggerType: string, triggerValue: string, context: any, instanceId: string) {

Â  Â  Â  Â  const startTime = Date.now();

Â  Â  Â  Â  const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

Â  Â  Â  Â Â 

Â  Â  Â  Â  console.log(`âš¡ Executing action rule: "${rule.ruleName}" (${rule.actionType})`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  // Check cooldown period

Â  Â  Â  Â  Â  Â  if (rule.cooldownMinutes > 0 && rule.lastExecutedAt) {

Â  Â  Â  Â  Â  Â  Â  Â  const cooldownEnd = new Date(rule.lastExecutedAt.getTime() + (rule.cooldownMinutes * 60 * 1000));

Â  Â  Â  Â  Â  Â  Â  Â  if (new Date() < cooldownEnd) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(`â° Rule "${rule.ruleName}" is in cooldown period`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Check daily execution limit

Â  Â  Â  Â  Â  Â  const today = new Date().toDateString();

Â  Â  Â  Â  Â  Â  const todayExecutions = await storage.getActionExecutionsToday(rule.ruleId);

Â  Â  Â  Â  Â  Â  if (todayExecutions >= rule.maxExecutionsPerDay) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`ğŸ“Š Rule "${rule.ruleName}" has reached daily execution limit`);

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Prepare trigger data

Â  Â  Â  Â  Â  Â  const triggerData = {

Â  Â  Â  Â  Â  Â  Â  Â  triggerType,

Â  Â  Â  Â  Â  Â  Â  Â  triggerValue,

Â  Â  Â  Â  Â  Â  Â  Â  context,

Â  Â  Â  Â  Â  Â  Â  Â  instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date().toISOString()

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Execute the action based on type

Â  Â  Â  Â  Â  Â  let result;

Â  Â  Â  Â  Â  Â  switch (rule.actionType) {

Â  Â  Â  Â  Â  Â  Â  Â  case 'create_task':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeCreateTask(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  case 'create_calendar_event':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeCreateCalendarEvent(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  case 'send_message':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeSendMessage(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  case 'add_label':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeAddLabel(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  case 'send_notification':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeSendNotification(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  case 'webhook':

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  result = await this.executeWebhook(rule.actionConfig, triggerData);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  Â  Â  default:

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`Unknown action type: ${rule.actionType}`);

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  const processingTime = Date.now() - startTime;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Log successful execution

Â  Â  Â  Â  Â  Â  await storage.createActionExecution({

Â  Â  Â  Â  Â  Â  Â  Â  ruleId: rule.ruleId,

Â  Â  Â  Â  Â  Â  Â  Â  triggeredBy: context.messageId || context.reactorJid,

Â  Â  Â  Â  Â  Â  Â  Â  triggerData,

Â  Â  Â  Â  Â  Â  Â  Â  status: 'success',

Â  Â  Â  Â  Â  Â  Â  Â  result,

Â  Â  Â  Â  Â  Â  Â  Â  executedAt: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  processingTimeMs: processingTime

Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Update rule statistics

Â  Â  Â  Â  Â  Â  await storage.updateActionRuleStats(rule.ruleId);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  console.log(`âœ… Action rule "${rule.ruleName}" executed successfully in ${processingTime}ms`);

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  } catch (error) {

Â  Â  Â  Â  Â  Â  const processingTime = Date.now() - startTime;

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  // Log failed execution

Â  Â  Â  Â  Â  Â  await storage.createActionExecution({

Â  Â  Â  Â  Â  Â  Â  Â  ruleId: rule.ruleId,

Â  Â  Â  Â  Â  Â  Â  Â  triggeredBy: context.messageId || context.reactorJid,

Â  Â  Â  Â  Â  Â  Â  Â  triggerData: {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  triggerType,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  triggerValue,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  context,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  instanceId,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timestamp: new Date().toISOString()

Â  Â  Â  Â  Â  Â  Â  Â  },

Â  Â  Â  Â  Â  Â  Â  Â  status: 'failed',

Â  Â  Â  Â  Â  Â  Â  Â  errorMessage: error.message,

Â  Â  Â  Â  Â  Â  Â  Â  executedAt: new Date(),

Â  Â  Â  Â  Â  Â  Â  Â  processingTimeMs: processingTime

Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  console.log(`âŒ Action rule "${rule.ruleName}" failed:`, error.message);

Â  Â  Â  Â  }

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute create task action - DEPRECATED: Use ActionsEngine instead

Â  Â  Â * This function is kept for backward compatibility but should not create new tasks

Â  Â  Â */

Â  Â  async executeCreateTask(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ“ Task creation requested from reaction trigger - redirecting to ActionsEngine`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Instead of creating a broken task, log the request and return success

Â  Â  Â  Â  // The ActionsEngine.processMessageForActions should handle the task creation

Â  Â  Â  Â  console.log(`ğŸ”„ Task creation config:`, JSON.stringify(config, null, 2));

Â  Â  Â  Â  console.log(`ğŸ“Š Trigger data:`, JSON.stringify(triggerData, null, 2));

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Return success without creating duplicate tasks

Â  Â  Â  Â  // The proper task creation happens in ActionsEngine.processMessageForActions

Â  Â  Â  Â  return {Â 

Â  Â  Â  Â  Â  Â  taskId: 'handled-by-actions-engine',Â 

Â  Â  Â  Â  Â  Â  title: 'Task creation handled by ActionsEngine',

Â  Â  Â  Â  Â  Â  note: 'This task creation was redirected to ActionsEngine to avoid duplicates'

Â  Â  Â  Â  };

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute create calendar event actionÂ Â 

Â  Â  Â */

Â  Â  async executeCreateCalendarEvent(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ“… Creating calendar event from reaction trigger`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  const eventData = {

Â  Â  Â  Â  Â  Â  title: config.title || `Event from ${triggerData.triggerType}: ${triggerData.triggerValue}`,

Â  Â  Â  Â  Â  Â  startTime: config.startTime ? new Date(config.startTime) : new Date(),

Â  Â  Â  Â  Â  Â  endTime: config.endTime ? new Date(config.endTime) : new Date(Date.now() + 60 * 60 * 1000), // 1 hour default

Â  Â  Â  Â  Â  Â  attendees: config.attendees || []

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Create calendar event using storage method

Â  Â  Â  Â  const event = await storage.createCalendarEvent({

Â  Â  Â  Â  Â  Â  title: eventData.title,

Â  Â  Â  Â  Â  Â  description: `Automated event from WhatsApp reaction`,

Â  Â  Â  Â  Â  Â  startTime: eventData.startTime,

Â  Â  Â  Â  Â  Â  endTime: eventData.endTime,

Â  Â  Â  Â  Â  Â  calendarId: 1, // Default calendar

Â  Â  Â  Â  Â  Â  isAllDay: false,

Â  Â  Â  Â  Â  Â  timezone: 'UTC',

Â  Â  Â  Â  Â  Â  providerEventId: `whatsapp-${Date.now()}` // Generate unique provider event ID

Â  Â  Â  Â  });

Â  Â  Â  Â Â 

Â  Â  Â  Â  return { eventId: event.eventId, title: event.title };

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute send message action

Â  Â  Â */

Â  Â  async executeSendMessage(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ’¬ Sending message from reaction trigger`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  const message = config.message || `Automated response to ${triggerData.triggerType}: ${triggerData.triggerValue}`;

Â  Â  Â  Â  const targetJid = config.targetJid || triggerData.context.reactorJid;

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Send message via Evolution API (would need to implement actual sending)

Â  Â  Â  Â  const result = {Â 

Â  Â  Â  Â  Â  Â  message,Â 

Â  Â  Â  Â  Â  Â  targetJid,Â 

Â  Â  Â  Â  Â  Â  sent: true,

Â  Â  Â  Â  Â  Â  timestamp: new Date().toISOString()Â 

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  return result;

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute add label action

Â  Â  Â */

Â  Â  async executeAddLabel(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ·ï¸ Adding label from reaction trigger`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  const labelData = {

Â  Â  Â  Â  Â  Â  name: config.labelName || `${triggerData.triggerType}_${triggerData.triggerValue}`,

Â  Â  Â  Â  Â  Â  color: config.color || '#007bff',

Â  Â  Â  Â  Â  Â  messageId: triggerData.context.messageId,

Â  Â  Â  Â  Â  Â  instanceId: triggerData.instanceId

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Add label to message/chat (assuming we have label methods)

Â  Â  Â  Â  const result = { labelName: labelData.name, applied: true };

Â  Â  Â  Â Â 

Â  Â  Â  Â  return result;

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute send notification action

Â  Â  Â */

Â  Â  async executeSendNotification(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ”” Sending notification from reaction trigger`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  const notification = {

Â  Â  Â  Â  Â  Â  title: config.title || 'WhatsApp Action Triggered',

Â  Â  Â  Â  Â  Â  message: config.message || `${triggerData.triggerType}: ${triggerData.triggerValue}`,

Â  Â  Â  Â  Â  Â  type: config.type || 'info'

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Send notification (would integrate with notification service)

Â  Â  Â  Â  const result = { notificationSent: true, title: notification.title };

Â  Â  Â  Â Â 

Â  Â  Â  Â  return result;

Â  Â  },



Â  Â  /**

Â  Â  Â * Execute webhook action

Â  Â  Â */

Â  Â  async executeWebhook(config: any, triggerData: any) {

Â  Â  Â  Â  console.log(`ğŸ”— Calling webhook from reaction trigger`);

Â  Â  Â  Â Â 

Â  Â  Â  Â  const webhookData = {

Â  Â  Â  Â  Â  Â  trigger: triggerData,

Â  Â  Â  Â  Â  Â  config: config,

Â  Â  Â  Â  Â  Â  timestamp: new Date().toISOString()

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  // Call external webhook (would need actual HTTP implementation)

Â  Â  Â  Â  const result = {Â 

Â  Â  Â  Â  Â  Â  webhookUrl: config.url,Â 

Â  Â  Â  Â  Â  Â  called: true,

Â  Â  Â  Â  Â  Â  data: webhookData

Â  Â  Â  Â  };

Â  Â  Â  Â Â 

Â  Â  Â  Â  return result;

Â  Â  },



Â  Â  /**

Â  Â  Â * Parses message content for NLP insights

Â  Â  Â */

Â  Â  parseMessageForNlp(text: string) {

Â  Â  Â  Â  const results = chrono.parse(text);

Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  Â  date: results.length > 0 ? results[0].start.date() : null,

Â  Â  Â  Â  Â  Â  location: null // Could be enhanced with location parsing

Â  Â  Â  Â  };

Â  Â  },



Â  Â  /**

Â  Â  Â * Maps API payload to WhatsApp chat structure

Â  Â  Â */

Â  Â  mapApiPayloadToWhatsappChat(rawChat: any, instanceId: string) {

Â  Â  Â  Â  return {

Â  Â  Â  Â  Â  Â  chat_id: rawChat.id,

Â  Â  Â  Â  Â  Â  instance_id: instanceId,

Â  Â  Â  Â  Â  Â  name: rawChat.name || '',

Â  Â  Â  Â  Â  Â  is_group: rawChat.id.includes('@g.us'),

Â  Â  Â  Â  Â  Â  created_at: new Date().toISOString(),

Â  Â  Â  Â  Â  Â  updated_at: new Date().toISOString()

Â  Â  Â  Â  };

Â  Â  }

};



// Export SSE connections for route handlers

export { sseConnections, notifyClientsOfNewMessage };




Show thinking
Of course. You are absolutely right to question that structure. While the code you've implemented has a lot of powerful new features, your intuition is correctâ€”architecturally, it is not ideal.

You've created a "monolithic" controller that is trying to do everything: handle HTTP requests, parse different API payload structures, map data, and execute business logic. This makes the code difficult to read, test, and maintain in the long run.

The multi-layered architecture we designed is the professional solution to this problem. I will now refactor the new functionality from your code into the correct layers, as shown in the diagram. This will result in a much cleaner, more robust, and more scalable application.

Here are the new, separated files.

This is the updated "Front Door." It is simple, clean, and its only job is to receive the request and pass it on.
1. Webhook Controller (webhook-controller.ts)
Jun 21, 12:39 PM

This is the "Translator." It contains all the logic for parsing the complex and sometimes inconsistent payloads from the Evolution API and mapping them into our clean, internal data structures.
2. WhatsApp API Adapter (whatsapp-api-adapter.ts)
Jun 21, 12:39 PM

Open

This is the "Brain" where all your complex business logic, NLP, and external API calls will live. It operates only on the clean data provided by the adapter.
3. Action Service (action-service.ts)
Jun 21, 12:39 PM

Open





